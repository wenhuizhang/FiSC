
// DO NOT EDIT -- automatically generated by ../gen-opt.pl
// from driver.default.options

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <assert.h>

#include "options.h"

using namespace std;

int __check__fsync = 0;

int __check__fsync_parents = 1;

int __check__ignore_missing = 0;

int __check__journal_data = 0;

int __check__mount_dir_sync = 0;

int __check__mount_sync = 0;

int __check__o_sync = 0;

int __check__sync = 0;

int __check__umount = 0;

const char* __fstest__mutate = NULL;

int __fstest__name_len = 256;

int __fstest__num_ops = 7;

int __stablefs__check_data_loss_only = 0;

int __stablefs__check_metadata_only = 0;

int __stablefs__sync = 0;



namespace {

struct _options: public options {

    virtual ~_options() {









    free((void*)__fstest__mutate);
	__fstest__mutate = NULL;










    }

    virtual void init() {








    __fstest__mutate = strdup("all_op");




    }

    virtual int load(const char *dom, const char *opt, const char *val) {
    if (!strcmp (dom, "check")) {
        if (!strcmp (opt, "fsync"))
            { __check__fsync = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "fsync_parents"))
            { __check__fsync_parents = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "ignore_missing"))
            { __check__ignore_missing = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "journal_data"))
            { __check__journal_data = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "mount_dir_sync"))
            { __check__mount_dir_sync = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "mount_sync"))
            { __check__mount_sync = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "o_sync"))
            { __check__o_sync = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "sync"))
            { __check__sync = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "umount"))
            { __check__umount = (int)strtoul(val, 0, 0); return 1; }

    }
    if (!strcmp (dom, "fstest")) {
        if (!strcmp (opt, "mutate"))
         {
             char *v = (char *)val;
             if(__fstest__mutate) free((void*)__fstest__mutate);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __fstest__mutate = strdup(val);
             return 1;
        }
        if (!strcmp (opt, "name_len"))
            { __fstest__name_len = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "num_ops"))
            { __fstest__num_ops = (int)strtoul(val, 0, 0); return 1; }

    }
    if (!strcmp (dom, "stablefs")) {
        if (!strcmp (opt, "check_data_loss_only"))
            { __stablefs__check_data_loss_only = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "check_metadata_only"))
            { __stablefs__check_metadata_only = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "sync"))
            { __stablefs__sync = (int)strtoul(val, 0, 0); return 1; }

    }

        return 0;
    }
    
    virtual void print(std::ostream &o) {
    o << "check::fsync    " << __check__fsync << endl;
    o << "check::fsync_parents    " << __check__fsync_parents << endl;
    o << "check::ignore_missing    " << __check__ignore_missing << endl;
    o << "check::journal_data    " << __check__journal_data << endl;
    o << "check::mount_dir_sync    " << __check__mount_dir_sync << endl;
    o << "check::mount_sync    " << __check__mount_sync << endl;
    o << "check::o_sync    " << __check__o_sync << endl;
    o << "check::sync    " << __check__sync << endl;
    o << "check::umount    " << __check__umount << endl;    o << "fstest::mutate    " << __fstest__mutate << endl;
    o << "fstest::name_len    " << __fstest__name_len << endl;
    o << "fstest::num_ops    " << __fstest__num_ops << endl;    o << "stablefs::check_data_loss_only    " << __stablefs__check_data_loss_only << endl;
    o << "stablefs::check_metadata_only    " << __stablefs__check_metadata_only << endl;
    o << "stablefs::sync    " << __stablefs__sync << endl;        
    }
    
};

struct register_options x(new _options);

}

