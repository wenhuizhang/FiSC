
// DO NOT EDIT -- automatically generated by ../gen-opt.pl
// from mcl.default.options

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <assert.h>

#include "options.h"

using namespace std;

const char* __mcl__ckpt_file = NULL;

int __mcl__ckpt_states = 1;

int __mcl__clear_on_bug_exit = 0;

int __mcl__max_bugs = 1;

int __mcl__max_state = 0;

int __mcl__persistent = 0;

int __mcl__random_seed = 1234;

int __mcl__reboot_crashes = 10000;

int __mcl__simulation = 0;

int __mcl__simulation_length = 1;

const char* __mcl__state_queue = NULL;

const char* __mcl__trace_dir = NULL;

int __mcl__verbose = 0;

const char* __monitor__addr = NULL;

int __monitor__port = 3000;

int __monitor__timeout = 1800;

int __monitor__use_vm = 0;

const char* __monitor__vm_path = NULL;



namespace {

struct _options: public options {

    virtual ~_options() {
    free((void*)__mcl__ckpt_file);
	__mcl__ckpt_file = NULL;










    free((void*)__mcl__state_queue);
	__mcl__state_queue = NULL;

    free((void*)__mcl__trace_dir);
	__mcl__trace_dir = NULL;


    free((void*)__monitor__addr);
	__monitor__addr = NULL;




    free((void*)__monitor__vm_path);
	__monitor__vm_path = NULL;




    }

    virtual void init() {
    __mcl__ckpt_file = strdup("./ckpt");









    __mcl__state_queue = strdup("dfs");
    __mcl__trace_dir = strdup("traces");
    __monitor__addr = strdup("127.0.0.1");



    __monitor__vm_path = strdup("../../vmware/explode/explode.vmx");
    }

    virtual int load(const char *dom, const char *opt, const char *val) {
    if (!strcmp (dom, "mcl")) {
        if (!strcmp (opt, "ckpt_file"))
         {
             char *v = (char *)val;
             if(__mcl__ckpt_file) free((void*)__mcl__ckpt_file);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __mcl__ckpt_file = strdup(val);
             return 1;
        }
        if (!strcmp (opt, "ckpt_states"))
            { __mcl__ckpt_states = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "clear_on_bug_exit"))
            { __mcl__clear_on_bug_exit = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "max_bugs"))
            { __mcl__max_bugs = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "max_state"))
            { __mcl__max_state = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "persistent"))
            { __mcl__persistent = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "random_seed"))
            { __mcl__random_seed = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "reboot_crashes"))
            { __mcl__reboot_crashes = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "simulation"))
            { __mcl__simulation = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "simulation_length"))
            { __mcl__simulation_length = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "state_queue"))
         {
             char *v = (char *)val;
             if(__mcl__state_queue) free((void*)__mcl__state_queue);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __mcl__state_queue = strdup(val);
             return 1;
        }
        if (!strcmp (opt, "trace_dir"))
         {
             char *v = (char *)val;
             if(__mcl__trace_dir) free((void*)__mcl__trace_dir);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __mcl__trace_dir = strdup(val);
             return 1;
        }
        if (!strcmp (opt, "verbose"))
            { __mcl__verbose = (int)strtoul(val, 0, 0); return 1; }

    }
    if (!strcmp (dom, "monitor")) {
        if (!strcmp (opt, "addr"))
         {
             char *v = (char *)val;
             if(__monitor__addr) free((void*)__monitor__addr);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __monitor__addr = strdup(val);
             return 1;
        }
        if (!strcmp (opt, "port"))
            { __monitor__port = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "timeout"))
            { __monitor__timeout = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "use_vm"))
            { __monitor__use_vm = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "vm_path"))
         {
             char *v = (char *)val;
             if(__monitor__vm_path) free((void*)__monitor__vm_path);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __monitor__vm_path = strdup(val);
             return 1;
        }

    }

        return 0;
    }
    
    virtual void print(std::ostream &o) {
    o << "mcl::ckpt_file    " << __mcl__ckpt_file << endl;
    o << "mcl::ckpt_states    " << __mcl__ckpt_states << endl;
    o << "mcl::clear_on_bug_exit    " << __mcl__clear_on_bug_exit << endl;
    o << "mcl::max_bugs    " << __mcl__max_bugs << endl;
    o << "mcl::max_state    " << __mcl__max_state << endl;
    o << "mcl::persistent    " << __mcl__persistent << endl;
    o << "mcl::random_seed    " << __mcl__random_seed << endl;
    o << "mcl::reboot_crashes    " << __mcl__reboot_crashes << endl;
    o << "mcl::simulation    " << __mcl__simulation << endl;
    o << "mcl::simulation_length    " << __mcl__simulation_length << endl;
    o << "mcl::state_queue    " << __mcl__state_queue << endl;
    o << "mcl::trace_dir    " << __mcl__trace_dir << endl;
    o << "mcl::verbose    " << __mcl__verbose << endl;    o << "monitor::addr    " << __monitor__addr << endl;
    o << "monitor::port    " << __monitor__port << endl;
    o << "monitor::timeout    " << __monitor__timeout << endl;
    o << "monitor::use_vm    " << __monitor__use_vm << endl;
    o << "monitor::vm_path    " << __monitor__vm_path << endl;        
    }
    
};

struct register_options x(new _options);

}

