
// DO NOT EDIT -- automatically generated by ../gen-opt.pl
// from storage.default.options

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <assert.h>

#include "options.h"

using namespace std;

int __fs__blk_size = 4096;

int __fs__retries_on_failed_umount = 10;

const char* __fs__type = NULL;

int __fsck__mode = 0;

int __fsck__verbose = 0;

const char* __raid__level = NULL;

const char* __svn__type = NULL;

int __vmware__compact = 0;



namespace {

struct _options: public options {

    virtual ~_options() {


    free((void*)__fs__type);
	__fs__type = NULL;



    free((void*)__raid__level);
	__raid__level = NULL;

    free((void*)__svn__type);
	__svn__type = NULL;








    }

    virtual void init() {


    __fs__type = strdup("ext3");
    __raid__level = strdup("raid1");    __svn__type = strdup("fsfs");
    }

    virtual int load(const char *dom, const char *opt, const char *val) {
    if (!strcmp (dom, "fs")) {
        if (!strcmp (opt, "blk_size"))
            { __fs__blk_size = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "retries_on_failed_umount"))
            { __fs__retries_on_failed_umount = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "type"))
         {
             char *v = (char *)val;
             if(__fs__type) free((void*)__fs__type);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __fs__type = strdup(val);
             return 1;
        }

    }
    if (!strcmp (dom, "fsck")) {
        if (!strcmp (opt, "mode"))
            { __fsck__mode = (int)strtoul(val, 0, 0); return 1; }
        if (!strcmp (opt, "verbose"))
            { __fsck__verbose = (int)strtoul(val, 0, 0); return 1; }

    }
    if (!strcmp (dom, "raid")) {
        if (!strcmp (opt, "level"))
         {
             char *v = (char *)val;
             if(__raid__level) free((void*)__raid__level);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __raid__level = strdup(val);
             return 1;
        }

    }
    if (!strcmp (dom, "svn")) {
        if (!strcmp (opt, "type"))
         {
             char *v = (char *)val;
             if(__svn__type) free((void*)__svn__type);
             if(v[0] == '\"') v++;
             if(v[strlen(v)-1] == '\"') v[strlen(v)-1]=0;
             __svn__type = strdup(val);
             return 1;
        }

    }
    if (!strcmp (dom, "vmware")) {
        if (!strcmp (opt, "compact"))
            { __vmware__compact = (int)strtoul(val, 0, 0); return 1; }

    }

        return 0;
    }
    
    virtual void print(std::ostream &o) {
    o << "fs::blk_size    " << __fs__blk_size << endl;
    o << "fs::retries_on_failed_umount    " << __fs__retries_on_failed_umount << endl;
    o << "fs::type    " << __fs__type << endl;    o << "fsck::mode    " << __fsck__mode << endl;
    o << "fsck::verbose    " << __fsck__verbose << endl;    o << "raid::level    " << __raid__level << endl;    o << "svn::type    " << __svn__type << endl;    o << "vmware::compact    " << __vmware__compact << endl;        
    }
    
};

struct register_options x(new _options);

}

