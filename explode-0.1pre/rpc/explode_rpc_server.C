/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "explode_rpc.h"
/* bluntly breaking the abstraction */
#include "driver/AbstFS.h"
#include "host_lib_impl.h"

int *
rpc_systemf_1_svc(char *cmd, struct svc_req *rqstp)
{
	static int  result;

	result = system(cmd);

	return &result;
}

int *
rpc_unlink_1_svc(char *pathname,  struct svc_req *rqstp)
{
        static int  result;

	result = unlink_impl(pathname);
	printf("pathname %s result %d\n", pathname, result);
	perror("");

        return &result;
}

int *
rpc_rmdir_1_svc(char *pathname,  struct svc_req *rqstp)
{
        static int  result;

        result = rmdir_impl(pathname);

        return &result;
}

int *
rpc_creat_1_svc(char *pathname, int mode,  struct svc_req *rqstp)
{
        static int  result;

        result = creat_impl(pathname, mode);

        return &result;
}

int *
rpc_creat_osync_1_svc(char *pathname, int mode,  struct svc_req *rqstp)
{
        static int  result;

	result = creat_osync_impl(pathname, mode);

        return &result;
}

int *
rpc_mkdir_1_svc(char *pathname, int mode,  struct svc_req *rqstp)
{
        static int  result;

	result = mkdir_impl(pathname, mode);

        return &result;
}

int *
rpc_link_1_svc(char *oldpath, char *newpath,  struct svc_req *rqstp)
{
        static int  result;

	result = link_impl(oldpath, newpath);

        return &result;
}

int *
rpc_symlink_1_svc(char *oldpath, char *newpath,  struct svc_req *rqstp)
{
        static int  result;

	result = symlink_impl(oldpath, newpath);

        return &result;
}

int *
rpc_rename_1_svc(char *oldpath, char *newpath,  struct svc_req *rqstp)
{
        static int  result;

	result = rename_impl(oldpath, newpath);

        return &result;
}

int *
rpc_truncate_1_svc(char *pathname, int length,  struct svc_req *rqstp)
{
        static int  result;

	result = truncate_impl(pathname, length);

        return &result;
}

int *
rpc_open_1_svc(char *pathname, int flags,  struct svc_req *rqstp)
{
        static int  result;

	result = open_impl(pathname, flags);

        return &result;
}

read_res *
rpc_read_1_svc(int fd, int count,  struct svc_req *rqstp)
{
        static read_res  result;
	int ret;

	result.read_res_u.buf.buffer_val = (char *) malloc(count);

	ret = read_impl(fd, result.read_res_u.buf.buffer_val, count);

	if(ret >= 0) {
	  result.errornum = 0;
	  result.read_res_u.buf.buffer_len = ret;
	} else
	  result.errornum = ret;

	printf("Count %d Len %d\n", result.read_res_u.buf.buffer_len, count); 

        return &result;
}

int *
rpc_write_1_svc(int fd, buffer buf, int count,  struct svc_req *rqstp)
{
        static int  result;

	assert(buf.buffer_len == count);

	result = write_impl(fd, buf.buffer_val, count);

	printf("Count %d Result %d\n", count, result);

        return &result;
}

int *
rpc_close_1_svc(int fd,  struct svc_req *rqstp)
{
        static int  result;

	result = close_impl(fd);

        return &result;
}

int *
rpc_fsync_1_svc(int fd,  struct svc_req *rqstp)
{
        static int  result;

	result = fsync_impl(fd);

        return &result;
}

int *
rpc_ftruncate_1_svc(int fd, int length,  struct svc_req *rqstp)
{
        static int  result;

	result = ftruncate_impl(fd, length);

        return &result;
}

int *
rpc_pwrite_1_svc(int fd, buffer buf, int count, int offset,  struct svc_req *rqstp)
{
        static int  result;

	assert(buf.buffer_len == count);

	result = pwrite_impl(fd, buf.buffer_val, count, offset);

        return &result;
}

int *
rpc_sync_1_svc(struct svc_req *rqstp)
{
        static int  result = 0;

	sync_impl();

        return &result;
}

stat_res *
rpc_stat_1_svc(char *pathname,  struct svc_req *rqstp)
{
        static stat_res result;

	result.errornum = stat_impl(pathname, (struct stat *) result.stat_res_u.buf);

        return &result;
}


abstract_path_res *
rpc_abstract_path_1_svc(char *pathname,  struct svc_req *rqstp)
{
        static abstract_path_res  result;
	AbstFS fs;
	char *buffer;
	int len;

	fs.abstract(pathname);

	// might leak memory

	fs.marshal(result.abstract_path_res_u.fs_buf.fs_buf_val,
		   (int &) result.abstract_path_res_u.fs_buf.fs_buf_len);

	//result.setsize(len);
	//memcpy(result.base(), buffer, len);

        return &result;
}
